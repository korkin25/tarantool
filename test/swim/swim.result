test_run = require('test_run').new()
---
...
test_run:cmd("push filter '\\.lua.*:[0-9]+: ' to '.lua:<line>: '")
---
- true
...
test_run:cmd("push filter '127.0.0.1:[0-9]+$' to '127.0.0.1:<port>'")
---
- true
...
msgpack = require('msgpack')
---
...
ffi = require('ffi')
---
...
--
-- gh-3234: SWIM gossip protocol.
--
-- Invalid cfg parameters.
swim.new(1)
---
- error: 'builtin/swim.lua:<line>: swim:cfg: expected table configuration'
...
swim.new({uri = true})
---
- error: 'builtin/swim.lua:<line>: swim:cfg: expected string URI or port number'
...
swim.new({heartbeat_rate = 'rate'})
---
- error: 'builtin/swim.lua:<line>: swim:cfg: expected number heartbeat_rate'
...
swim.new({ack_timeout = 'timeout'})
---
- error: 'builtin/swim.lua:<line>: swim:cfg: expected number ack_timeout'
...
swim.new({gc_mode = 'not a mode'})
---
- error: 'builtin/swim.lua:<line>: swim:cfg: unknown gc_mode'
...
swim.new({gc_mode = 0})
---
- error: 'builtin/swim.lua:<line>: swim:cfg: unknown gc_mode'
...
swim.new({uuid = 123})
---
- error: 'builtin/swim.lua:<line>: swim:cfg: expected string UUID or struct tt_uuid'
...
swim.new({uuid = '1234'})
---
- error: 'builtin/swim.lua:<line>: swim:cfg: invalid UUID'
...
-- Valid parameters, but invalid configuration.
swim.new({})
---
- null
- 'swim.cfg: UUID and URI are mandatory in a first config'
...
swim.new({uuid = uuid(1)})
---
- null
- 'swim.cfg: UUID and URI are mandatory in a first config'
...
swim.new({uri = uri()})
---
- null
- 'swim.cfg: UUID and URI are mandatory in a first config'
...
-- Check manual deletion.
s = swim.new({uuid = uuid(1), uri = uri()})
---
...
s:delete()
---
...
s:cfg({})
---
- error: 'builtin/swim.lua:<line>: the swim instance is deleted'
...
s = nil
---
...
_ = collectgarbage('collect')
---
...
s = swim.new({uuid = uuid(1), uri = uri()})
---
...
s:quit()
---
...
s:is_configured()
---
- error: '[string "return s:is_configured() "]:1: the swim instance is deleted'
...
s = nil
---
...
_ = collectgarbage('collect')
---
...
s = swim.new({uuid = uuid(1), uri = uri()})
---
...
s:is_configured()
---
- true
...
s:size()
---
- 1
...
s.cfg
---
- uuid: 00000000-0000-1000-8000-000000000001
  uri: 127.0.0.1:<port>
...
s.cfg.gc_mode = 'off'
---
- error: '[string "s.cfg.gc_mode = ''off'' "]:1: please, use swim:cfg{key = value}
    instead of swim.cfg.key = value'
...
s:cfg{gc_mode = 'off'}
---
- true
...
s.cfg
---
- gc_mode: off
  uuid: 00000000-0000-1000-8000-000000000001
  uri: 127.0.0.1:<port>
...
s.cfg.gc_mode
---
- off
...
s.cfg.uuid
---
- 00000000-0000-1000-8000-000000000001
...
s.cfg()
---
- error: 'builtin/swim.lua:<line>: swim:cfg: first argument is not a SWIM instance'
...
s:cfg({wrong_opt = 100})
---
- error: 'swim:cfg: unknown option wrong_opt'
...
s:delete()
---
...
-- Reconfigure.
s = swim.new()
---
...
s:is_configured()
---
- false
...
-- Check that not configured instance does not provide most of
-- methods.
s.quit == nil
---
- true
...
s:cfg({uuid = uuid(1), uri = uri()})
---
- true
...
s.quit ~= nil
---
- true
...
s:is_configured()
---
- true
...
s:size()
---
- 1
...
s = nil
---
...
_ = collectgarbage('collect')
---
...
-- Invalid usage.
s = swim.new()
---
...
s.delete()
---
- error: 'builtin/swim.lua:<line>: swim:delete: first argument is not a SWIM instance'
...
s.is_configured()
---
- error: 'builtin/swim.lua:<line>: swim:is_configured: first argument is not a SWIM instance'
...
s.cfg()
---
- error: 'builtin/swim.lua:<line>: swim:cfg: first argument is not a SWIM instance'
...
s:delete()
---
...
--
-- Basic member table manipulations.
--
s1 = swim.new({uuid = uuid(1), uri = uri(), heartbeat_rate = 0.01})
---
...
s2 = swim.new({uuid = uuid(2), uri = listen_uri, heartbeat_rate = 0.01})
---
...
s1.broadcast()
---
- error: 'builtin/swim.lua:<line>: swim:broadcast: first argument is not a SWIM instance'
...
s1:broadcast('wrong port')
---
- error: 'swim:broadcast: expected number port'
...
-- Note, broadcast takes a port, not a URI.
s1:broadcast('127.0.0.1:3333')
---
- error: 'swim:broadcast: expected number port'
...
-- Ok to broadcast on default port.
s1:broadcast()
---
- true
...
s1:broadcast(listen_port)
---
- true
...
while s2:size() ~= 2 or s1:size() ~= 2 do fiber.sleep(0.01) s1:broadcast(listen_port) end
---
...
s2:delete()
---
...
s1.remove_member()
---
- error: 'builtin/swim.lua:<line>: swim:remove_member: first argument is not a SWIM instance'
...
s1:remove_member(100)
---
- error: 'builtin/swim.lua:<line>: swim:remove_member: expected string UUID or struct
    tt_uuid'
...
s1:remove_member('1234')
---
- error: 'builtin/swim.lua:<line>: swim:remove_member: invalid UUID'
...
s1:remove_member(uuid(2)) size = s1:size()
---
...
size
---
- 1
...
s1.add_member()
---
- error: 'builtin/swim.lua:<line>: swim:add_member: first argument is not a SWIM instance'
...
s1:add_member(100)
---
- error: 'swim:add_member: expected table member definition'
...
s1:add_member({uri = true})
---
- error: 'builtin/swim.lua:<line>: swim:add_member: expected string URI or port number'
...
s1:add_member({uri = listen_uri})
---
- null
- 'swim.add_member: URI and UUID are mandatory'
...
s1:add_member({uuid = uuid(2)})
---
- null
- 'swim.add_member: URI and UUID are mandatory'
...
s1:remove_member(uuid(2)) s1:add_member({uri = listen_uri, uuid = uuid(2)})
---
...
s1:add_member({uri = listen_uri, uuid = uuid(2)})
---
- null
- 'swim.add_member: a member with such UUID already exists'
...
s1:size()
---
- 2
...
s1:cfg({uuid = uuid(3)}) old_self = s1:member_by_uuid(uuid(1))
---
...
s1:self():uuid()
---
- 00000000-0000-1000-8000-000000000003
...
old_self
---
- uri: 127.0.0.1:<port>
  status: left
  incarnation: 1
  uuid: 00000000-0000-1000-8000-000000000001
  payload_size: 0
...
-- Can't remove self.
s1:remove_member(uuid(3))
---
- null
- 'swim.remove_member: can not remove self'
...
-- Not existing.
s1:remove_member(uuid(4))
---
- true
...
-- Old self.
s1:remove_member(uuid(1))
---
- true
...
s1:delete()
---
...
s1 = swim.new({uuid = uuid(1), uri = uri()})
---
...
s2 = swim.new({uuid = uuid(2), uri = listen_uri})
---
...
s1.probe_member()
---
- error: 'builtin/swim.lua:<line>: swim:probe_member: first argument is not a SWIM instance'
...
s1:probe_member()
---
- null
- 'swim.probe_member: URI is mandatory'
...
s1:probe_member(true)
---
- error: 'builtin/swim.lua:<line>: swim:probe_member: expected string URI or port number'
...
-- Not existing URI is ok - nothing happens.
s1:probe_member('127.0.0.1:1')
---
- true
...
fiber.yield()
---
...
s1:size()
---
- 1
...
s1:probe_member(listen_uri)
---
- true
...
while s1:size() ~= 2 do fiber.sleep(0.01) end
---
...
s2:size()
---
- 2
...
s1:delete()
---
...
s2:delete()
---
...
--
-- Member API.
--
s1 = swim.new({uuid = uuid(1), uri = uri()})
---
...
s = s1:self()
---
...
s
---
- uri: 127.0.0.1:<port>
  status: alive
  incarnation: 1
  uuid: 00000000-0000-1000-8000-000000000001
  payload_size: 0
...
s:status()
---
- alive
...
s:uuid()
---
- 00000000-0000-1000-8000-000000000001
...
s:uri()
---
- 127.0.0.1:<port>
...
s:incarnation()
---
- 1
...
s:payload_cdata()
---
- 'cdata<const char *>: NULL'
- 0
...
s:payload_str()
---
- null
...
s:payload()
---
- null
...
s:is_dropped()
---
- false
...
s.unknown_index
---
- null
...
s.status()
---
- error: 'builtin/swim.lua:<line>: member:status(): first argument is not a SWIM member'
...
s.uuid()
---
- error: 'builtin/swim.lua:<line>: member:uuid(): first argument is not a SWIM member'
...
s.uri()
---
- error: 'builtin/swim.lua:<line>: member:uri(): first argument is not a SWIM member'
...
s.incarnation()
---
- error: 'builtin/swim.lua:<line>: member:incarnation(): first argument is not a SWIM
    member'
...
s.payload_cdata()
---
- error: 'builtin/swim.lua:<line>: member:payload_cdata(): first argument is not a SWIM
    member'
...
s.payload_str()
---
- error: 'builtin/swim.lua:<line>: member:payload_str(): first argument is not a SWIM
    member'
...
s.payload()
---
- error: 'builtin/swim.lua:<line>: member:payload(): first argument is not a SWIM member'
...
s.is_dropped()
---
- error: 'builtin/swim.lua:<line>: member:is_dropped(): first argument is not a SWIM
    member'
...
s1:member_by_uuid(uuid(1)) ~= nil
---
- true
...
s1:member_by_uuid(50)
---
- error: 'builtin/swim.lua:<line>: swim:member_by_uuid: expected string UUID or struct
    tt_uuid'
...
s1:member_by_uuid(uuid(2))
---
- null
...
-- UUID can be cdata.
s1:member_by_uuid(s:uuid())
---
- uri: 127.0.0.1:<port>
  status: alive
  incarnation: 1
  uuid: 00000000-0000-1000-8000-000000000001
  payload_size: 0
...
s1:quit()
---
...
s:status()
---
- left
...
s:is_dropped()
---
- true
...
--
-- Payload.
--
s = swim.new({uuid = uuid(1), uri = uri()})
---
...
s.set_payload()
---
- error: 'builtin/swim.lua:<line>: swim:set_payload: first argument is not a SWIM instance'
...
s.set_payload_raw()
---
- error: 'builtin/swim.lua:<line>: swim:set_payload_raw: first argument is not a SWIM
    instance'
...
self = s:self()
---
...
s:set_payload()
---
- true
...
self:payload()
---
- null
...
s:set_payload({a = 100})
---
- true
...
self:payload()
---
- {'a': 100}
...
s:set_payload(100)
---
- true
...
self:payload()
---
- 100
...
s:set_payload(false)
---
- true
...
self:payload()
---
- false
...
p = self:payload_str()
---
...
p
---
- !!binary wg==
...
(msgpack.decode(p))
---
- false
...
p, size = self:payload_cdata()
---
...
type(p)
---
- cdata
...
size
---
- 1
...
(msgpack.decode(p, size))
---
- false
...
s:set_payload(string.rep('a', 1500))
---
- null
- Payload should be <= 1200 and >= 0
...
self:payload()
---
- false
...
s:set_payload()
---
- true
...
self:payload()
---
- null
...
s:set_payload(100)
---
- true
...
self:payload()
---
- 100
...
s:set_payload_raw()
---
- true
...
self:payload()
---
- null
...
-- Raw payload setting can be used when MessagePack is not needed,
-- or already encoded.
s:set_payload_raw(nil, '123')
---
- error: 'builtin/swim.lua:<line>: swim:set_payload_raw: expected number payload size'
...
s:set_payload_raw('123', -1)
---
- null
- Payload should be <= 1200 and >= 0
...
size = 10
---
...
cdata = ffi.new('int[?]', size)
---
...
for i = 0, size - 1 do cdata[i] = i end
---
...
bsize = ffi.sizeof('int') * size
---
...
s:set_payload_raw(cdata)
---
- error: 'builtin/swim.lua:<line>: swim:set_payload_raw: size is mandatory for cdata
    payload'
...
s:set_payload_raw('str', 4)
---
- error: 'builtin/swim.lua:<line>: swim:set_payload_raw: explicit payload size > string
    length'
...
s:set_payload_raw(true)
---
- error: 'builtin/swim.lua:<line>: swim:set_payload_raw: payload should be either string
    or cdata'
...
s:set_payload_raw(cdata, bsize)
---
- true
...
self:payload_str():len() == bsize
---
- true
...
self_cdata, self_bsize = self:payload_cdata()
---
...
self_bsize == bsize
---
- true
...
self_cdata = ffi.cast('int *', self_cdata)
---
...
for i = 0, size - 1 do assert(self_cdata[i] == cdata[i]) end
---
...
s:set_payload_raw('raw str')
---
- true
...
self:payload_str()
---
- raw str
...
s:set_payload_raw('raw str', 3)
---
- true
...
self:payload_str()
---
- raw
...
s:delete()
---
...
self:is_dropped()
---
- true
...
--
-- Check payload dissemination.
--
s1 = swim.new({uuid = uuid(1), uri = uri(), heartbeat_rate = 0.01})
---
...
s2 = swim.new({uuid = uuid(2), uri = listen_port, heartbeat_rate = 0.01})
---
...
s1:add_member({uuid = uuid(2), uri = listen_port})
---
- true
...
while s2:size() ~= 2 do fiber.sleep(0.01) end
---
...
s1_view = s2:member_by_uuid(uuid(1))
---
...
s1_view:payload()
---
- null
...
s1_view:incarnation()
---
- 1
...
s1:set_payload('payload')
---
- true
...
while s1_view:payload() ~= 'payload' do fiber.sleep(0.01) end
---
...
s1_view:incarnation()
---
- 2
...
s1:set_payload('payload2')
---
- true
...
while s1_view:payload() ~= 'payload2' do fiber.sleep(0.01) end
---
...
s1_view:incarnation()
---
- 3
...
s1:delete()
---
...
s2:delete()
---
...
--
-- Iterators.
--
function iterate() local t = {} for k, v in s:pairs() do table.insert(t, {k, v}) end return t end
---
...
s = swim.new()
---
...
iterate()
---
- error: '[string "function iterate() local t = {} for k, v in s..."]:1: attempt to
    call method ''pairs'' (a nil value)'
...
s:cfg({uuid = uuid(1), uri = uri(), gc_mode = 'off'})
---
- true
...
s.pairs()
---
- error: 'builtin/swim.lua:<line>: swim:pairs: first argument is not a SWIM instance'
...
iterate()
---
- - - 00000000-0000-1000-8000-000000000001
    - uri: 127.0.0.1:<port>
      status: alive
      incarnation: 1
      uuid: 00000000-0000-1000-8000-000000000001
      payload_size: 0
...
s:add_member({uuid = uuid(2), uri = uri()})
---
- true
...
iterate()
---
- - - 00000000-0000-1000-8000-000000000002
    - uri: 127.0.0.1:<port>
      status: alive
      incarnation: 0
      uuid: 00000000-0000-1000-8000-000000000002
      payload_size: 0
  - - 00000000-0000-1000-8000-000000000001
    - uri: 127.0.0.1:<port>
      status: alive
      incarnation: 1
      uuid: 00000000-0000-1000-8000-000000000001
      payload_size: 0
...
s:add_member({uuid = uuid(3), uri = uri()})
---
- true
...
iterate()
---
- - - 00000000-0000-1000-8000-000000000001
    - uri: 127.0.0.1:<port>
      status: alive
      incarnation: 1
      uuid: 00000000-0000-1000-8000-000000000001
      payload_size: 0
  - - 00000000-0000-1000-8000-000000000003
    - uri: 127.0.0.1:<port>
      status: alive
      incarnation: 0
      uuid: 00000000-0000-1000-8000-000000000003
      payload_size: 0
  - - 00000000-0000-1000-8000-000000000002
    - uri: 127.0.0.1:<port>
      status: alive
      incarnation: 0
      uuid: 00000000-0000-1000-8000-000000000002
      payload_size: 0
...
s:delete()
---
...
--
-- Payload caching.
--
s1 = swim.new({uuid = uuid(1), uri = uri(listen_port), heartbeat_rate = 0.01})
---
...
s2 = swim.new({uuid = uuid(2), uri = uri(), heartbeat_rate = 0.01})
---
...
s1_self = s1:self()
---
...
_ = s1:add_member({uuid = s2:self():uuid(), uri = s2:self():uri()})
---
...
_ = s2:add_member({uuid = s1_self:uuid(), uri = s1_self:uri()})
---
...
s1:size()
---
- 2
...
s2:size()
---
- 2
...
s1_view = s2:member_by_uuid(s1_self:uuid())
---
...
s1:set_payload({a = 100})
---
- true
...
p = s1_self:payload()
---
...
s1_self:payload() == p
---
- true
...
while not s1_view:payload() do fiber.sleep(0.01) end
---
...
p = s1_view:payload()
---
...
s1_view:payload() == p
---
- true
...
-- Now a complex case. It is possible, that a new member's
-- incarnation is learned, but new payload is not. Payload cache
-- should correctly process that.
s1:cfg({heartbeat_rate = 1000})
---
- true
...
s2:cfg({heartbeat_rate = 1000})
---
- true
...
s1:set_payload({a = 200})
---
- true
...
-- Via probe() S2 learns new incarnation of S1, but without new
-- payload.
s2:probe_member(s1_self:uri())
---
- true
...
s1_view:payload()
---
- {'a': 100}
...
s1_view:incarnation()
---
- 2
...
s1:cfg({heartbeat_rate = 0.01})
---
- true
...
s2:cfg({heartbeat_rate = 0.01})
---
- true
...
while s1_view:payload().a ~= 200 do fiber.sleep(0.01) end
---
...
p = s1_view:payload()
---
...
s1_view:payload() == p
---
- true
...
p
---
- {'a': 200}
...
s1_view:incarnation()
---
- 2
...
s1:delete()
---
...
s2:delete()
---
...
--
-- Member table cache in Lua.
--
s = swim.new({uuid = uuid(1), uri = uri()})
---
...
self = s:self()
---
...
s:self() == self
---
- true
...
s:add_member({uuid = uuid(2), uri = 1})
---
- true
...
s2 = s:member_by_uuid(uuid(2))
---
...
s2
---
- uri: 127.0.0.1:<port>
  status: alive
  incarnation: 0
  uuid: 00000000-0000-1000-8000-000000000002
  payload_size: 0
...
-- Next lookups return the same member table.
s2_old_uri = s2:uri()
---
...
-- Check, that it is impossible to take removed member from the
-- cached table.
s:remove_member(uuid(2))
---
- true
...
s:member_by_uuid(uuid(2))
---
- null
...
-- GC automatically removes members from the member table.
self = nil
---
...
s2 = nil
---
...
collectgarbage('collect')
---
- 0
...
s.cache_table
---
- []
...
s:add_member({uuid = uuid(2), uri = 2})
---
- true
...
s2 = s:member_by_uuid(uuid(2))
---
...
s2:uri() ~= s2_old_uri
---
- true
...
s:delete()
---
...
--
-- Encryption.
--
s1 = swim.new({uuid = uuid(1), uri = uri()})
---
...
s2 = swim.new({uuid = uuid(2), uri = uri()})
---
...
s1.set_codec()
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: first argument is not a SWIM instance'
...
s1:set_codec(100)
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: expected table codec configuration'
...
s1:set_codec({})
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: unknown crypto algorithm'
...
s1:set_codec({algo = 100})
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: unknown crypto algorithm'
...
cfg = {algo = 'aes128', mode = 'unknown'}
---
...
s1:set_codec(cfg)
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: unknown crypto algorithm mode'
...
cfg.mode = 'cbc'
---
...
s1:set_codec(cfg)
---
- null
- key size expected 16, got 0
...
cfg.key_size = 'str'
---
...
s1:set_codec(cfg)
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: expected number key size'
...
cfg.key_size = 200
---
...
cfg.key = true
---
...
s1:set_codec(cfg)
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: key should be either string or cdata'
...
cfg.key = 'key'
---
...
s1:set_codec(cfg)
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: explicit key size > string length'
...
cfg.key = ffi.new('char[?]', 20)
---
...
cfg.key_size = nil
---
...
s1:set_codec(cfg)
---
- error: 'builtin/swim.lua:<line>: swim:set_codec: size is mandatory for cdata key'
...
cfg.key_size = 20
---
...
s1:set_codec(cfg)
---
- null
- key size expected 16, got 20
...
cfg.key = '1234567812345678'
---
...
cfg.key_size = 16
---
...
s1:set_codec(cfg)
---
- true
...
-- S2 does not use encryption and can't decode the ping.
s1:probe_member(s2:self():uri())
---
- true
...
fiber.sleep(0.01)
---
...
s1:size()
---
- 1
...
s2:size()
---
- 1
...
s2:set_codec(cfg)
---
- true
...
s1:probe_member(s2:self():uri())
---
- true
...
while s1:size() ~= 2 do fiber.sleep(0.01) end
---
...
s2:size()
---
- 2
...
s1:remove_member(s2:self():uuid()) s2:remove_member(s1:self():uuid())
---
...
-- Set different private key - again can't decode.
cfg.key = '8765432187654321'
---
...
cfg.key_size = nil
---
...
s2:set_codec(cfg)
---
- true
...
s1:probe_member(s2:self():uri())
---
- true
...
fiber.sleep(0.01)
---
...
s1:size()
---
- 1
...
s2:size()
---
- 1
...
cfg.key = '12345678'
---
...
cfg.algo = 'des'
---
...
cfg.mode = 'cfb'
---
...
s1:set_codec(cfg)
---
- true
...
s1:probe_member(s2:self():uri())
---
- true
...
fiber.sleep(0.01)
---
...
s1:size()
---
- 1
...
s2:size()
---
- 1
...
s1:set_codec({algo = 'none'})
---
- true
...
s2:set_codec({algo = 'none'})
---
- true
...
s1:probe_member(s2:self():uri())
---
- true
...
while s1:size() ~= 2 do fiber.sleep(0.01) end
---
...
s2:size()
---
- 2
...
s1:delete()
---
...
s2:delete()
---
...
test_run:cmd("clear filter")
---
- true
...
